# 符号表管理功能说明

## 概述

符号表管理功能是华为微码映射项目的一个重要组成部分，用于从输入文件中提取 bundle/function 的 proto 或 def 节点，统一管理并去重，优先保留 proto。在后续处理 jmp 或 call 时，查找并补充对应的原型信息。

## 功能特性

### ✅ 阶段 1：收集阶段（Build Symbol Table）
- 遍历所有 AST 节点
- 识别四种关键节点：
  - `bundle_def`
  - `function_def`
  - `bundle_proto`
  - `function_proto`
- 将信息存储到全局符号表中
- 规则：
  - 同一名字的项，只存一份
  - 优先级：proto > def
  - 如果是 def 类型，不存它自己，而是存它的第一个子节点（代表其原型结构）

### ✅ 阶段 2：引用收集阶段（Collect References）
- 再次遍历 AST，查找所有引用点：
  - jmp 操作（跳转目标）
  - func::CallOp（函数调用）
- 提取这些操作的目标名称（symbol name）
- 记录这些名字，形成"待解析引用列表"

### ✅ 阶段 3：补全与插入阶段（Patch & Insert）
- 对每个"被调用函数名"：
  - 在"原型信息库"中查找对应项
  - 如果找到：在调用点前插入该原型的完整结构

## 实现架构

### 核心类：SymbolTableManager

```cpp
class SymbolTableManager {
private:
    std::map<std::string, ProtoInfo> symbolTable;           // 符号表
    std::vector<ReferenceInfo> references;                  // 引用列表
    std::set<std::string> unresolvedReferences;            // 未解析的引用
    
public:
    void buildSymbolTable(BaseAST* root);                   // 阶段1
    void collectReferences(BaseAST* root);                  // 阶段2
    void patchAndInsert();                                  // 阶段3
};
```

### 数据结构

#### ProtoInfo（原型信息）
```cpp
struct ProtoInfo {
    std::string name;                    // 函数/bundle名称
    BaseAST* protoNode;                  // 原型节点
    BaseAST* defNode;                    // 定义节点（如果有）
    bool isBundle;                       // 是否是bundle
    bool isProto;                        // 是否是原型（优先级更高）
};
```

#### ReferenceInfo（引用信息）
```cpp
struct ReferenceInfo {
    std::string targetName;              // 目标名称
    BaseAST* referenceNode;              // 引用节点（jmp或func_call）
    bool isJmp;                          // 是否是跳转
    bool isFuncCall;                     // 是否是函数调用
    int depth;                           // 引用深度
};
```

## 使用方法

### 1. 集成到现有流程

符号表管理功能已经集成到 `MicrocodeMappingEngine` 中，在 `preprocessASTs()` 方法中自动执行：

```cpp
// 在 preprocessASTs() 方法中
if (swAnalyzer->getRoot()) {
    // 阶段1：构建符号表
    symbolTableManager->buildSymbolTable(swAnalyzer->getRoot());
    
    // 阶段2：收集引用
    symbolTableManager->collectReferences(swAnalyzer->getRoot());
    
    // 阶段3：补全和插入
    symbolTableManager->patchAndInsert();
}
```

### 2. 运行测试

使用提供的测试脚本：

```bash
./utils/test-symbol-table.sh
```

### 3. 查看输出

测试完成后，可以在输出目录中查看结果：

```bash
ls -la tmp/symbol-table-test/
```

## 输出信息

### 控制台输出
- 阶段1：显示收集的原型和定义信息
- 阶段2：显示收集的引用信息
- 阶段3：显示补全统计信息

### 统计信息
- 符号表大小
- 引用数量
- 未解析引用数量

## 技术细节

### AST节点类型识别

```cpp
bool isProtoNode(BaseAST* node) const {
    return (node->getType() == AST_NODE_TYPE::AST_BUNDLE_PROTO ||
            node->getType() == AST_NODE_TYPE::AST_FUNCTION_PROTO);
}

bool isDefNode(BaseAST* node) const {
    return (node->getType() == AST_NODE_TYPE::AST_BUNDLE_DEF ||
            node->getType() == AST_NODE_TYPE::AST_FUNCTION_DEF);
}
```

### 名称提取

```cpp
std::string extractNameFromNode(BaseAST* node) const {
    // 对于proto和def节点，名称通常在第一个子节点的第一个子节点
    if (isProtoNode(node) || isDefNode(node)) {
        if (node->getDown() && node->getDown()->getDown()) {
            return node->getDown()->getDown()->getText();
        }
    }
    
    // 对于jmp和func_call节点，目标名称在第一个子节点
    if (isJmpNode(node) || isFuncCallNode(node)) {
        if (node->getDown()) {
            return node->getDown()->getText();
        }
    }
    
    return "";
}
```

## 扩展性

### 添加新的节点类型
1. 在 `ASTNodeInfo.h` 中定义新的节点类型
2. 在 `SymbolTableManager` 中添加相应的识别方法
3. 更新名称提取逻辑

### 自定义优先级规则
可以修改 `collectProtosAndDefs` 方法中的优先级逻辑来适应不同的需求。

## 注意事项

1. **内存管理**：当前实现使用指针引用，不负责内存管理
2. **线程安全**：当前实现不是线程安全的
3. **错误处理**：需要根据实际使用情况添加更多的错误处理
4. **性能优化**：对于大型AST，可能需要考虑性能优化

## 未来改进

1. **完整的原型插入**：当前的原型插入是框架性的，需要根据具体AST结构完善
2. **内存管理**：添加智能指针管理
3. **错误恢复**：添加更完善的错误处理机制
4. **性能监控**：添加性能统计和监控
5. **配置化**：支持配置文件来调整行为